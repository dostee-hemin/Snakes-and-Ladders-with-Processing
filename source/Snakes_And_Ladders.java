/* autogenerated by Processing revision 1293 on 2024-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Snakes_And_Ladders extends PApplet {

// Dimension must be no less than 3 (board size = dimension * dimension)
int dimension;
// Number of players must be no more than 10
int numberOfPlayers;
Tile[] board;
Player[] players;
Passage[] passages;

float angleOffset;
float spacing;
int currentTurn;
int currentRoll;
boolean canRoll;
boolean rollGoesOver;
int rollCount;
float tileSize;

float playerMovementSpeed = 0.2f;
int dimensionSelected = 10;
int GameState = -3;
int currentPlayerColorSelect = 0;

int[] chosenColors;
int[] playerColors = {
  color(0, 150, 255), 
  color(255, 255, 0), 
  color(0, 255, 0), 
  color(255, 50, 50), 
  color(255, 126, 249), 
  color(255, 145, 0), 
  color(242), 
  color(136, 100, 255), 
  color(3, 244, 255), 
  color(50, 160, 0)
};

public void setup() {
  /* size commented out by preprocessor */;

  LoadImages();
  textFont(createFont("BalooChettan2-Bold.ttf", 100));
  
  rectMode(CENTER);
  imageMode(CENTER);
  textAlign(CENTER);
}

public void draw() {
  switch(GameState) {
  case -3:
    DisplayNumberOfPlayersSelect();
    break;
  case -2:
    DisplayColorSelect();
    break;
  case -1:
    DisplayDimensionSelect();
    break;
  case 0:
    DisplayGame();

    for (Player p : players) {
      p.update();
    }

    if (rollCount > 0) {
      if (frameCount % 5 == 0) {
        rollCount--;
        currentRoll = floor(random(1, 7));
      }
    } else if (rollCount == 0) {
      players[currentTurn].move(currentRoll);
      rollCount--;
    }
    break;
  case 1:
    DisplayEndScreen();
    break;
  }
}
public void DisplayNumberOfPlayersSelect() {
  // Display background wood image
  noTint();
  image(woodImage, width/2, height/2);

  // Display title text
  fill(255);
  textSize(50);
  text("Choose number", width/2, 70);
  text("of players", width/2, 130);
  
  // Display a grid of buttons, 
  // each with a different number of players
  strokeWeight(10);
  int s = 50;      // Size of the button
  for (int i=0; i<3; i++) {
    for (int j=0; j<3; j++) {
      // Calculate the number based on the column and row
      int number = i*3 + j + 1;
      
      //Find the x and y position of the button
      float x = 300 + j*150;
      float y = 250 + i*150;
      
      // Display the button
      stroke(200);
      fill(255);
      rect(x, y, 120, 120, 7);
      
      // Display the players inside the button
      switch(number) {
      case 9:
        tint(playerColors[8]);
        image(playerImage, x+20, y+20, s, s);
      case 8:
        tint(playerColors[7]);
        image(playerImage, x-20, y+20, s, s);
      case 7:
        tint(playerColors[6]);
        image(playerImage, x+20, y-20, s, s);
      case 6:
        tint(playerColors[5]);
        image(playerImage, x-20, y-20, s, s);
      case 5:
        tint(playerColors[4]);
        image(playerImage, x, y+20, s, s);
      case 4:
        tint(playerColors[3]);
        image(playerImage, x, y-20, s, s);
      case 3:
        tint(playerColors[2]);
        image(playerImage, x+20, y, s, s);
      case 2:
        tint(playerColors[1]);
        image(playerImage, x-20, y, s, s);
      case 1:
        tint(playerColors[0]);
        image(playerImage, x, y, s, s);
        break;
      }
    }
  }
  
  //Display the tenth button (for ten players)
  stroke(200);
  fill(255);
  rect(width/2, 700, 260, 120, 7);
  
  // Display all the players in the tenth button
  for (int i=0; i<5; i++) {
    for (int j=0; j<2; j++) {
      int index = i + j*5;
      float x = width/2 - 100 + i*50;
      float y = 675 + j*50;
      tint(playerColors[index]);
      image(playerImage, x, y, s, s);
    }
  }
}

public void DisplayColorSelect() {
  // Display background wood image
  noTint();
  image(woodImage, width/2, height/2);
  
  // Display title text
  fill(255);
  textSize(60);
  text("Player " + (currentPlayerColorSelect+1) + ",", width/2, 70);
  text("choose your color", width/2, 130);
  
  // Display every color of the players
  // only if it hasn't been selected
  for (int i=0; i<5; i++) {
    for (int j=0; j<2; j++) {
      int index = i + j*5;
      if (!colorExists(playerColors[index])) {
        float x = width/2 - 300 + i*150;
        float y = height/2 - 100 + j*200;
        tint(playerColors[index]);
        image(playerImage, x, y, 150, 150);
      }
    }
  }
}

public void DisplayDimensionSelect() {
  // Display background wood image
  noTint();
  image(woodImage, width/2, height/2);
  
  // Display title text
  fill(255);
  textSize(60);
  text("Select the dimension", width/2, 70);
  text("of your grid", width/2, 130);

  // Counter box
  fill(0xFF0072C6);
  stroke(0xFF014476);
  strokeWeight(10);
  rect(width/2, height/2, 200, 100, 10);

  // Dimension size text
  fill(0xFFF0CD02);
  textSize(85);
  text(dimensionSelected, width/2, height/2+30);

  // Dark plus and minus outline
  strokeWeight(25);
  line(width/2-200, height/2, width/2-150, height/2);
  line(width/2+150, height/2, width/2+200, height/2);
  line(width/2+175, height/2 - 25, width/2+175, height/2 + 25);

  // Bright plus and minus filling
  stroke(0xFF037CFA);
  strokeWeight(10);
  line(width/2-200, height/2, width/2-150, height/2);
  line(width/2+150, height/2, width/2+200, height/2);
  line(width/2+175, height/2 - 25, width/2+175, height/2 + 25);

  // "Next" Button
  fill(0xFF00D321);
  stroke(0xFF008B16);
  strokeWeight(10);
  rect(width/2, height-200, 250, 100, 10);

  // "Next" text
  fill(0xFFFCC200);
  textSize(100);
  text("Next", width/2, height-170);
}

public void DisplayGame() {
  // Display background garden image
  noTint();
  image(backgroundImage, width/2, height/2);
  
  // Black filling in the board
  fill(0);
  noStroke();
  rect(width/2, height/2, width-300, height-200);
  
  // Case that holds the players
  fill(100);
  stroke(200);
  strokeWeight(7);
  rect(40, 400, 120, 640, 7);

  // Display the board
  for (Tile t : board) {
    t.display();
  }

  // Display the snakes and ladders on the board
  for (Passage p : passages) {
    p.display();
  }

  // Display the players
  for (Player p : players) {
    p.display();
  }

  // Display the outline of the dice (once a roll has been made)
  if (rollCount == -1 && currentRoll > 0) {
    // Red outline when roll is not allowed
    if (rollGoesOver) {
      stroke(255, 0, 0);
    } 
    // Yellow outline when roll is allowed
    else {
      stroke(255, 255, 0, 225);
    }
    strokeWeight(10);
    noFill();
    rect(width-75, 75, 93, 93, 15);
  } else {
    // Display an empty dice slot if there is no roll
    stroke(255, 150);
    strokeWeight(10);
    fill(255, 100);
    rect(width-75, 75, 80, 80, 15);
  }


  // Display the current player's turn in a box at the top of the screen
  // Box
  fill(players[currentTurn].playerColor);
  stroke(0xFF502E0C);
  strokeWeight(10);
  rect(width/2, 40, 290, 50, 10);
  // Text
  fill(darker(players[currentTurn].playerColor));
  textSize(40);
  text("Player " + (currentTurn+1) + "'s Turn", width/2, 50);

  // Display the dice if it's being rolled
  if (currentRoll > 0) {
    DisplayDice(currentRoll);
  }
}

public void DisplayEndScreen() {
  // Display background winner image
  noTint();
  image(winnerImage, width/2, height/2);
  
  // Write which player wins on top of the trophy
  fill(darker(players[currentTurn].playerColor));
  textSize(80);
  text("PLAYER " + (currentTurn+1) + " WINS!!!", width/2+5, 185);
  fill(players[currentTurn].playerColor);
  text("PLAYER " + (currentTurn+1) + " WINS!!!", width/2, 180);
  
  // Put the player's piece on the trophy
  tint(players[currentTurn].playerColor);
  image(playerImage, width/2, 310, 80, 80);
  
  // Write the reset and replay text at the bottom
  fill(255);
  textSize(30);
  text("Press 'n' to generate a new board", width/2, height-70);
  text("Press 'r' to rest the game", width/2, height-20);
}


public void DisplayDice(int face) {
  // Display a sqaure
  fill(255);
  stroke(0);
  strokeWeight(10);
  rect(width-75, 75, 80, 80, 15);
  
  // Display the dots based on the dice's face
  strokeWeight(19);
  switch(face) {
  case 1:
    point(width-75, 75);
    break;
  case 2:
    point(width-95, 95);
    point(width-55, 55);
    break;
  case 3:
    point(width-75, 75);
    point(width-95, 95);
    point(width-55, 55);
    break;
  case 4:
    point(width-95, 95);
    point(width-55, 55);
    point(width-95, 55);
    point(width-55, 95);
    break;
  case 5:
    point(width-75, 75);
    point(width-95, 95);
    point(width-55, 55);
    point(width-95, 55);
    point(width-55, 95);
    break;
  case 6:
    point(width-95, 75);
    point(width-95, 95);
    point(width-95, 55);
    point(width-55, 75);
    point(width-55, 95);
    point(width-55, 55);
    break;
  }
}
public void Reset() {
  GameState = -3;
  currentPlayerColorSelect = 0;
  dimensionSelected = 10;
  if (GameState < 0) {
    return;
  }
  SetupBoard();
}

public void SetupBoard() {
  board = new Tile[dimension*dimension];
  players = new Player[numberOfPlayers];
  passages  = new Passage[dimension];

  GameState = 0;
  currentTurn = 0;
  currentRoll = 0;
  canRoll = true;
  rollGoesOver = false;
  rollCount = -1;
  angleOffset = PI/numberOfPlayers;
  spacing = angleOffset * 2;


  tileSize = 600.0f/PApplet.parseFloat(dimension);
  float offset = tileSize * 0.5f;
  for (int i=0; i<dimension; i++) {
    float y = height-100-i*tileSize - offset;
    for (int j=0; j<dimension; j++) {
      float x = width-150 - j*tileSize - offset;
      if (i%2 == 0) {
        x = 150+j*tileSize + offset;
      }
      board[(i*dimension)+j] = new Tile(x, y, (i*dimension)+j+1);
    }
  }

  for (int i=0; i<players.length; i++) {
    players[i] = new Player(120 + i*60, chosenColors[i]);
  }

  for (int i=0; i<passages.length; i++) {
    if (i % 2 == 0) {
      passages[i] = new Snake();
    } else {
      passages[i] = new Ladder();
    }
  }

  for (Passage p : passages) {
    p.FindStartTile();
  }

  int t = PApplet.parseInt(tileSize);
  tileType1.resize(t, t);
  tileType2.resize(t, t);
  tileTypeFinish.resize(t, t);
}

public int darker(int original) {
  return color(red(original) * 0.6f, green(original) * 0.6f, blue(original) * 0.6f);
}

public boolean colorExists(int c) {
  for (int current : chosenColors) {
    if (current == c) {
      return true;
    }
  }
  return false;
}

public void CheckForOverlap() {
  for (int i=0; i<players.length; i++) {
    Player p = players[i];
    boolean result = false;
    for (int j=0; j<players.length; j++) {
      if (i == j) {
        continue;
      }
      Player other = players[j];
      if (other.currentTile == p.currentTile) {
        other.isOverlapped = true;
        result = true;
      }
    }
    p.isOverlapped = result;
  }

  for (int i=0; i<players.length; i++) {
    Player p = players[i];
    if (p.currentTile == -1) {
      continue;
    }
    if (p.isOverlapped && p.movesLeft < 1) {
      Tile t = board[p.currentTile];
      PVector dir = PVector.fromAngle(TWO_PI - angleOffset - spacing*i).setMag(tileSize/4.44f);
      p.target = t.location.copy().add(dir);
      p.isOverlapped = false;
    } else {
      Tile t = board[p.currentTile];
      p.target = t.location.copy();
    }
  }
}

public void nextTurn() {
  currentTurn++;
  if (currentTurn > players.length-1) {
    currentTurn = 0;
  }
  if (!rollGoesOver) {
    currentRoll = 0;
  }
  canRoll = true;
}
class Passage {
  int startTile;
  int endTile;
  PVector startLocation;
  PVector endLocation;

  Passage() {
  }

  public void display() {
    println("ERROR! Displaying in Parent Class");
  }

  public void FindStartTile() {
    println("ERROR! Finding start tile in Parent Class");
  }

  public boolean movePlayer(Player p) {
    println("ERROR! Moving player in Parent Class");
    return false;
  }
}

class Ladder extends Passage {
  float startupX;
  PVector dir;
  float ladderLength;
  Ladder() {
  }

  public void display() {
    drawLadder(0xFF834001, 50/dimension);
    drawLadder(0xFFE87000, 0);
  }

  public void drawLadder(int strokeColor, int offset) {
    pushMatrix();
    translate(startLocation.x + offset, startLocation.y + offset);
    rotate(dir.heading());
    stroke(strokeColor);
    strokeWeight(70.0f/dimension);
    int sizeVal = PApplet.parseInt(110.0f/dimension);
    line(0, -sizeVal, startupX, -sizeVal);
    line(0, sizeVal, startupX, sizeVal);
    for (int x=sizeVal*2; x<startupX; x+=sizeVal*2) {
      line(x, -sizeVal, x, sizeVal);
    }
    if (startupX < ladderLength) {
      startupX += ladderLength / 55;
    } else {
      startupX = ladderLength;
    }
    popMatrix();
  }

  public void FindStartTile() {
    boolean startExists = true;
    while (startExists) {
      startExists = false;
      startTile = floor(random(board.length-dimension));
      for (Passage other : passages) {
        if (other != this) {
          if (this.startTile == other.startTile || this.startTile == other.endTile) {
            startExists = true;
          }
        }
      }
    }
    boolean endExists = true;
    while (endExists) {
      endExists = false;
      endTile = floor(random(startTile+1, board.length));
      if (floor(endTile/dimension) == floor(startTile/dimension)) {
        endExists = true;
        continue;
      }
      for (Passage other : passages) {
        if (other != this) {
          if (this.endTile == other.startTile || this.endTile == other.endTile) {
            endExists = true;
          }
        }
      }
    }

    startLocation = board[startTile].location;
    endLocation = board[endTile].location;

    dir = PVector.sub(endLocation, startLocation);
    ladderLength = dir.mag();
  }

  public boolean movePlayer(Player p) {
    if (PVector.dist(p.location, endLocation) < 5) {
      return false;
    }
    PVector movement = dir.copy().setMag(tileSize/16);
    p.location.add(movement);
    return true;
  }
}

class Snake extends Passage {
  PVector[] points;
  int c1;
  int c2;
  int startupI;
  int eatenIndex;
  PVector dir;
  int barLength = 90/dimension;
  float baseSize = 170.0f/dimension;

  Snake() {
    c1 = color(random(100, 255), random(100, 255), random(100, 255));
    c2 = color(red(c1) - random(20, 50), green(c1) - random(20, 50), blue(c1) - random(20, 50));
  }

  public void GeneratePoints() {
    int lengthInPixels = PApplet.parseInt(dir.mag());
    int halfCycles = PApplet.parseInt(lengthInPixels/tileSize);
    float lengthInRadians = halfCycles * PI;
    points = new PVector[PApplet.parseInt(dir.mag())];
    for (int i=0; i<points.length; i++) {
      float x = i;
      int amplitude = PApplet.parseInt(sin((x/lengthInPixels) * PI) * tileSize);
      float y = amplitude * sin((x/lengthInPixels) * lengthInRadians);
      points[i] = new PVector(x, y);
      points[i].rotate(dir.heading());
      points[i].add(startLocation);
    }
    startupI = points.length-1;
  }

  public void display() {
    noStroke();
    for (int i=startupI; i<points.length; i++) {
      PVector p = points[i];
      if (PApplet.parseInt(i/barLength) % 2 == 0) {
        fill(c1);
      } else {
        fill(c2);
      }
      if (eatenIndex == i && eatenIndex != 0) {
        ellipse(p.x, p.y, tileSize/2, tileSize/2);
      } else {
        ellipse(p.x, p.y, baseSize, baseSize);
      }
    }
    if (startupI > 0) {
      startupI -= points.length/30;
      if (startupI < 0) {
        startupI = 0;
      }
    } else {
      pushMatrix();
      translate(startLocation.x, startLocation.y);
      rotate(dir.heading());
      fill(c1);
      ellipse(0, 0, baseSize*1.5f, baseSize*1.5f);
      ellipse(-baseSize*0.5f, 0, baseSize, baseSize);
      fill(c2);
      ellipse(0, -baseSize*0.4f, baseSize*0.5f, baseSize*0.5f);
      ellipse(0, baseSize*0.4f, baseSize*0.5f, baseSize*0.5f);
      popMatrix();
    }
  }

  public void FindStartTile() {
    boolean startExists = true;
    while (startExists) {
      startExists = false;
      startTile = floor(random(dimension, board.length-1));
      for (Passage other : passages) {
        if (other != this) {
          if (this.startTile == other.startTile || this.startTile == other.endTile) {
            startExists = true;
          }
        }
      }
    }
    boolean endExists = true;
    while (endExists) {
      endExists = false;
      endTile = floor(random(startTile-1));
      if (floor(endTile/dimension) == floor(startTile/dimension)) {
        endExists = true;
        continue;
      }
      for (Passage other : passages) {
        if (other != this) {
          if (this.endTile == other.startTile || this.endTile == other.endTile) {
            endExists = true;
          }
        }
      }
    }

    startLocation = board[startTile].location;
    endLocation = board[endTile].location;

    dir = PVector.sub(endLocation, startLocation);

    GeneratePoints();
  }

  public boolean movePlayer(Player p) {
    if (eatenIndex > points.length-1) {
      eatenIndex = 0;
      p.canBeDisplayed = true;
      return false;
    }
    p.location = points[eatenIndex].copy();
    eatenIndex += 5;
    p.canBeDisplayed = false;
    return true;
  }
}
class Player {
  PVector location;
  PVector target;
  int playerColor;
  int currentTile = -1;
  int movesLeft = 0;
  boolean isOverlapped;
  Passage passageTaken = null;
  boolean canBeDisplayed = true;

  Player(float y, int playerColor) {
    location  = new PVector(40, y);
    target = location;
    this.playerColor = playerColor;
  }

  public void display() {
    if (canBeDisplayed) {
      tint(playerColor);
      image(playerImage, location.x,location.y, tileSize/1.5f, tileSize/1.5f);
    }
  }

  public void update() {
    if (passageTaken != null) {
      if (!passageTaken.movePlayer(this)) {
        target = passageTaken.endLocation.copy();
        currentTile = passageTaken.endTile;
        passageTaken = null;
      }
      return;
    }
    location.lerp(target, playerMovementSpeed);
    if (PVector.dist(location, target) < 5) {
      if (movesLeft > 0) {
        currentTile++;
        Tile t = board[currentTile];
        target = t.location.copy();
        movesLeft--;
        CheckForOverlap();
      } else if (movesLeft == 0) {
        if (currentTile == board.length-1) {
          GameState = 1;
          return;
        }
        for (Passage p : passages) {
          if (currentTile == p.startTile) {
            passageTaken = p;
            location = p.startLocation.copy();
            return;
          }
        }
        CheckForOverlap();
        movesLeft--;
        nextTurn();
      }
    }
  }

  public void move(int amount) {
    if (currentTile + amount >= board.length) {
      rollGoesOver = true;
      nextTurn();
      return;
    }
    movesLeft = amount;
    Tile t = board[currentTile+1];
    target = t.location.copy();
  }
}
PImage backgroundImage;
PImage winnerImage;
PImage playerImage;
PImage woodImage;
PImage tileType1;
PImage tileType2;
PImage tileTypeFinish;

public void LoadImages() {
  backgroundImage = loadImage("Images/background.png");
  winnerImage = loadImage("Images/winner.png");
  winnerImage.resize(900, 800);
  playerImage = loadImage("Images/player.png");
  woodImage = loadImage("Images/wood.jpg");
  woodImage.resize(900, 800);
  tileType1 = loadImage("Images/tile1.png");
  tileType2 = loadImage("Images/tile2.png");
  tileTypeFinish = loadImage("Images/tile3.png");
}
class Tile {
  PVector location;
  int tileNumber;

  Tile(float x, float y, int tileNumber) {
    location = new PVector(x, y);
    this.tileNumber = tileNumber;
  }

  public void display() {
    noTint();
    if(tileNumber == board.length) {
      image(tileTypeFinish, location.x,location.y);
    } else if (tileNumber % 2 == 0) {
      image(tileType1, location.x,location.y);
    } else {
      image(tileType2, location.x,location.y);
    }
    fill(150);
    textSize(tileSize/2.2f);
    text(tileNumber, location.x+tileSize*0.05f, location.y + tileSize*0.11f);
    fill(255);
    textSize(tileSize/2.3f);
    text(tileNumber, location.x, location.y + tileSize*0.1f);
  }
}
public void keyPressed() {
  switch(key) {
  case 'r':
    Reset();
    break;
  case 'n':
    if (GameState > -1) {
      SetupBoard();
    }
    break;
  case ' ':
    if (canRoll) {
      canRoll = false;
      rollGoesOver = false;
      rollCount = 10;
    }
    break;
  }
}

public void mousePressed() {
  switch(GameState) {
  case -3:
    for (int i=0; i<3; i++) {
      for (int j=0; j<3; j++) {
        int index = i*3 + j;
        float x = 300 + j*150;
        float y = 250 + i*150;
        if (mouseX > x-60 && 
          mouseX < x+60 && 
          mouseY > y-60 && 
          mouseY < y+60) {
          GameState = -2;
          numberOfPlayers = index+1;
          chosenColors = new int[numberOfPlayers];
          for (int k=0; k<numberOfPlayers; k++) {
            chosenColors[k] = color(0);
          }
        }
      }
    }

    if (mouseX > width/2-130 && 
      mouseX < width/2+130 && 
      mouseY > 680 && 
      mouseY < 720) {
      GameState = -2;
      numberOfPlayers = 10;
      chosenColors = new int[numberOfPlayers];
      for (int i=0; i<numberOfPlayers; i++) {
        chosenColors[i] = color(0);
      }
    }
    break;
  case -2:
    for (int i=0; i<5; i++) {
      for (int j=0; j<2; j++) {
        int index = i + j*5;
        if (!colorExists(playerColors[index])) {
          float x = width/2 - 300 + i*150;
          float y = height/2 - 100 + j*200;
          if (dist(x, y, mouseX, mouseY) < 50) {
            chosenColors[currentPlayerColorSelect] = playerColors[index];
            currentPlayerColorSelect++;
            if (currentPlayerColorSelect == numberOfPlayers) {
              GameState = -1;
            }
          }
        }
      }
    }
    break;
  case -1:
    if (dist(mouseX, mouseY, width/2-175, height/2) < 50) {
      dimensionSelected --;
      if (dimensionSelected < 3) {
        dimensionSelected = 3;
      }
    } else if (dist(mouseX, mouseY, width/2+175, height/2) < 50) {
      dimensionSelected ++;
      if (dimensionSelected > 30) {
        dimensionSelected = 30;
      }
    } else if (mouseX > width/2-125 &&
      mouseX < width/2+125 &&
      mouseY > height-250 &&
      mouseY < height+250) {
      GameState = 0;
      dimension = dimensionSelected;
      SetupBoard();
    }
    break;
  }
}


  public void settings() { size(900, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Snakes_And_Ladders" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
